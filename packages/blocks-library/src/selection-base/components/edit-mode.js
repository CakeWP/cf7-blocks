/**
 * WordPress Dependencies
 */
import { __ } from '@wordpress/i18n';
import { clone, isEmpty } from 'lodash';
import { useRef } from '@wordpress/element';
import { trash, plusCircle } from '@wordpress/icons';
import { ENTER, BACKSPACE } from '@wordpress/keycodes';
import { Button, TextControl } from '@wordpress/components';

/**
 * Custom Dependencies
 */
import PropTypes from 'prop-types';

function EditMode( props ) {
	const {
		id,
		type,
		name,
		isRequired,
		isLabelFirst,
		autogeneratedName,
	} = props;

	const handleFocus = ( index ) => {
		let selectionBaseWrapper = document.querySelectorAll(
			'.wp-block-cf7-blocks-selection-base'
		);
		selectionBaseWrapper.forEach( ( wrapper ) => {
			let selectionBase = wrapper.querySelectorAll(
				'.cf7blocks-selection-field'
			);
			selectionBase.forEach( ( field, fieldIndex ) => {
				if ( index === fieldIndex ) {
					field
						.querySelector(
							'.cf7-blocks-selection-field-label input'
						)
						.focus();
				}
			} );
		} );
	};

	const handleChange = ( updatedItem, index ) => {
		const newItems = clone( props.items );

		newItems[ index ] = updatedItem; // Updating.

		props.onUpdate( newItems );
	};
	const handleAdd = ( index ) => {
		const newItem = {
			label: '',
			checked: false,
		};
		if ( typeof index === 'undefined' ) {
			props.onUpdate( [ ...props.items, newItem ] );
		} else {
			let newItems = clone( props.items );
			newItems.splice( index, 0, newItem );
			props.onUpdate( newItems );

			handleFocus( index );
		}
	};
	const handleDelete = ( index ) => {
		const newItems = props.items.filter(
			( _, itemIndex ) => index !== itemIndex
		);

		props.onUpdate( newItems );
		handleFocus( index - 1 );
	};

	const handleKeyDown = ( event, index ) => {
		const { keyCode } = event;
		if ( keyCode === ENTER ) {
			handleAdd( index + 1 );
		}
		if ( keyCode === BACKSPACE && event.target.value.trim() === '' ) {
			handleDelete( index );
		}
	};
	return (
		<>
			{ props.items.map( ( item, index ) => {
				const label = (
					<TextControl
						value={ item.label }
						className="cf7-blocks-selection-field-label"
						placeholder={ __( 'Add Label', 'cf7-blocks' ) }
						onKeyDown={ ( event ) => handleKeyDown( event, index ) }
						onChange={ ( newLabel ) =>
							handleChange( { ...item, label: newLabel }, index )
						}
					/>
				);

				return (
					<div
						className={ `cf7blocks-selection-field` }
						key={ index }
					>
						{ isLabelFirst && label }
						<input
							id={ id }
							type={ type }
							name={
								isEmpty( name )
									? autogeneratedName + '[]'
									: name + '[]'
							}
							checked={ item.checked }
							isRequired={ isRequired }
							value={ item.label }
						/>
						{ ! isLabelFirst && label }
						<Button
							icon={ trash }
							onClick={ () => handleDelete( index ) }
						/>
					</div>
				);
			} ) }
			<Button icon={ plusCircle } onClick={ () => handleAdd() }>
				{ __( 'Add Option', 'cf7-blocks' ) }
			</Button>
		</>
	);
}

EditMode.propTypes = {
	/** Selection items */
	items: PropTypes.arrayOf(
		PropTypes.shape( {
			/** Is the item checked? */
			checked: PropTypes.bool.isRequired,

			/** Item label */
			labe: PropTypes.string.isRequired,
		} )
	),

	/** Callback that will be called with updated items on change. */
	onUpdate: PropTypes.func.isRequired,
};

export default EditMode;
