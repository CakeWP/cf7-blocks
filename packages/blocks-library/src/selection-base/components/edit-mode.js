/**
 * WordPress Dependencies
 */
import { __ } from '@wordpress/i18n';
import { clone, isEmpty } from 'lodash';
import { useEffect, useRef } from '@wordpress/element';
import { trash, plus } from '@wordpress/icons';
import { ENTER, BACKSPACE } from '@wordpress/keycodes';
import { Button, TextControl, ToolbarButton } from '@wordpress/components';

/**
 * Custom Dependencies
 */
import PropTypes from 'prop-types';

function EditMode( props ) {
	const inputElements = useRef( [] );

	const {
		id,
		type,
		name,
		isRequired,
		isLabelFirst,
		isFirstBlankItem,
		autogeneratedName,
	} = props;

	const handleFocus = ( index ) => {
		inputElements.current[ index ].focus();
	};

	const handleChange = ( updatedItem, index ) => {
		const newItems = clone( props.items );

		newItems[ index ] = updatedItem; // Updating.

		props.onUpdate( newItems );
	};
	const handleAdd = ( index = null ) => {
		const newItem = {
			label: '',
			checked: false,
		};

		if ( index === null ) {
			props.onUpdate( [ ...props.items, newItem ] );
		} else {
			let newItems = clone( props.items );
			newItems.splice( index, 0, newItem );

			props.onUpdate( newItems );

			handleFocus( index );
		}
	};

	const handleDelete = ( index ) => {
		if ( index === 0 ) return; // preventing the first option from being deleted.

		const newItems = props.items.filter(
			( _, itemIndex ) => index !== itemIndex
		);

		props.onUpdate( newItems );
		handleFocus( index - 1 );
	};

	const handleKeyDown = ( event, index ) => {
		const { keyCode } = event;
		if ( keyCode === ENTER ) {
			handleAdd( index + 1, event.target );
		}
		if ( keyCode === BACKSPACE && event.target.value === '' ) {
			handleDelete( index, event.target );
		}
	};

	return (
		<>
			{ props.items.map( ( item, index ) => {
				const label = (
					<TextControl
						value={ item.label }
						className="cf7-blocks-selection-field-label"
						ref={ ( ref ) => {
							inputElements.current[ index ] = ref;
						} }
						placeholder={ __( 'Add Label', 'cf7-blocks' ) }
						onKeyDown={ ( event ) =>
							setTimeout( () => handleKeyDown( event, index ), 0 )
						}
						onChange={ ( newLabel ) =>
							handleChange( { ...item, label: newLabel }, index )
						}
					/>
				);

				const value = index === 0 && isFirstBlankItem ? '' : item.label;
				const fieldName = ( isEmpty( name )
					? autogeneratedName
					: name
				).concat( '[]' );

				return (
					<div key={ index } className="cf7blocks-selection-field">
						{ isLabelFirst && label }
						{ type !== 'select' && (
							<input
								id={ id }
								type={ type }
								value={ value }
								name={ fieldName }
								onChange={ () => null }
								checked={ item.checked }
								isRequired={ isRequired }
							/>
						) }
						{ ! isLabelFirst && label }
						<Button
							isSmall
							icon={ trash }
							label={ __( 'Delete Option', 'cf7-blocks' ) }
							onClick={ () => handleDelete( index ) }
						/>
					</div>
				);
			} ) }
			<ToolbarButton isPressed onClick={ () => handleAdd() }>
				{ __( 'Add Option', 'cf7-blocks' ) }
			</ToolbarButton>
		</>
	);
}

EditMode.propTypes = {
	/** Selection items */
	items: PropTypes.arrayOf(
		PropTypes.shape( {
			/** Is the item checked? */
			checked: PropTypes.bool.isRequired,

			/** Item label */
			labe: PropTypes.string.isRequired,
		} )
	),

	/** Callback that will be called with updated items on change. */
	onUpdate: PropTypes.func.isRequired,
};

export default EditMode;
